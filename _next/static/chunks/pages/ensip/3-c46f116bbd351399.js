(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6623],{7089:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/ensip/3",function(){return r(4564)}])},4564:function(e,n,r){"use strict";r.r(n),r.d(n,{__N_SSG:function(){return o}});var s=r(1527),t=r(313);function a(e){let n=Object.assign({p:"p",h1:"h1",table:"table",thead:"thead",tr:"tr",th:"th",strong:"strong",a:"a",tbody:"tbody",td:"td",h2:"h2",ul:"ul",li:"li",code:"code",h3:"h3",h4:"h4",pre:"pre"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181)."}),"\n",(0,s.jsx)(n.h1,{children:"ENSIP-3: Reverse Resolution"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Author"})}),(0,s.jsxs)(n.th,{children:["Nick Johnson <",(0,s.jsx)(n.a,{href:"mailto:nick@ens.domains",children:"nick@ens.domains"}),">"]})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Status"})}),(0,s.jsx)(n.td,{children:"Final"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Submitted"})}),(0,s.jsx)(n.td,{children:"2016-12-01"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,s.jsx)(n.p,{children:"This ENSIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question."}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(n.p,{children:"While name services are mostly used for forward resolution - going from human-readable identifiers to machine-readable ones - there are many use-cases in which reverse resolution is useful as well:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applications that allow users to monitor accounts benefit from showing the name of an account instead of its address, even if it was originally added by address."}),"\n",(0,s.jsx)(n.li,{children:"Attaching metadata such as descriptive information to an address allows retrieving this information regardless of how the address was originally discovered."}),"\n",(0,s.jsx)(n.li,{children:"Anyone can configure a name to resolve to an address, regardless of ownership of that address. Reverse records allow the owner of an address to claim a name as authoritative for that address."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,s.jsxs)(n.p,{children:["Reverse ENS records are stored in the ENS hierarchy in the same fashion as regular records, under a reserved domain, ",(0,s.jsx)(n.code,{children:"addr.reverse"}),". To generate the ENS name for a given account's reverse records, convert the account to hexadecimal representation in lower-case, and append ",(0,s.jsx)(n.code,{children:"addr.reverse"}),". For instance, the ENS registry's address at ",(0,s.jsx)(n.code,{children:"0x112234455c3a32fd11230c42e7bccd4a84e02010"})," has any reverse records stored at ",(0,s.jsx)(n.code,{children:"112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Note that this means that contracts wanting to do dynamic reverse resolution of addresses will need to perform hex encoding in the contract."}),"\n",(0,s.jsx)(n.h3,{children:"Registrar"}),"\n",(0,s.jsxs)(n.p,{children:["The owner of the ",(0,s.jsx)(n.code,{children:"addr.reverse"})," domain will be a registrar that permits the caller to take ownership of the reverse record for their own address. It provides the following methods:"]}),"\n",(0,s.jsx)(n.h4,{children:"function claim(address owner) returns (bytes32 node)"}),"\n",(0,s.jsxs)(n.p,{children:["When called by account ",(0,s.jsx)(n.code,{children:"x"}),", instructs the ENS registry to transfer ownership of the name ",(0,s.jsx)(n.code,{children:"hex(x) + '.addr.reverse'"})," to the provided address, and return the namehash of the ENS record thus transferred."]}),"\n",(0,s.jsx)(n.p,{children:"Allowing the caller to specify an owner other than themselves for the relevant node facilitates contracts that need accurate reverse ENS entries delegating this to their creators with a minimum of code inside their constructor:"}),"\n",(0,s.jsx)(n.pre,{code:"reverseRegistrar.claim(msg.sender)\n",children:(0,s.jsx)(n.code,{children:"reverseRegistrar.claim(msg.sender)\n"})}),"\n",(0,s.jsx)(n.h4,{children:"function claimWithResolver(address owner, address resolver) returns (bytes32 node)"}),"\n",(0,s.jsxs)(n.p,{children:["When called by account ",(0,s.jsx)(n.code,{children:"x"}),", instructs the ENS registry to set the resolver of the name ",(0,s.jsx)(n.code,{children:"hex(x) + '.addr.reverse'"})," to the specified resolver, then transfer ownership of the name to the provided address, and return the namehash of the ENS record thus transferred. This method facilitates setting up a custom resolver and owner in fewer transactions than would be required if calling ",(0,s.jsx)(n.code,{children:"claim"}),"."]}),"\n",(0,s.jsx)(n.h4,{children:"function setName(string name) returns (bytes32 node)"}),"\n",(0,s.jsxs)(n.p,{children:["When called by account ",(0,s.jsx)(n.code,{children:"x"}),", sets the resolver for the name ",(0,s.jsx)(n.code,{children:"hex(x) + '.addr.reverse'"})," to a default resolver, and sets the name record on that name to the specified name. This method facilitates setting up simple reverse records for users in a single transaction."]}),"\n",(0,s.jsx)(n.h3,{children:"Resolver interface"}),"\n",(0,s.jsx)(n.p,{children:"A new resolver interface is defined, consisting of the following method:"}),"\n",(0,s.jsx)(n.pre,{code:"function name(bytes32 node) constant returns (string);\n",children:(0,s.jsx)(n.code,{children:"function name(bytes32 node) constant returns (string);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Resolvers that implement this interface must return a valid ENS name for the requested node, or the empty string if no name is defined for the requested node."}),"\n",(0,s.jsx)(n.p,{children:"The interface ID of this interface is 0x691f3431."}),"\n",(0,s.jsx)(n.p,{children:"Future ENSIPs may specify more record types appropriate to reverse ENS records."}),"\n",(0,s.jsx)(n.h2,{id:"appendix-1-registrar-implementation",children:"Appendix 1: Registrar implementation"}),"\n",(0,s.jsx)(n.p,{children:"This registrar, written in Solidity, implements the specifications outlined above."}),"\n",(0,s.jsx)(n.pre,{code:"pragma solidity ^0.4.10;\n\nimport \"./AbstractENS.sol\";\n\ncontract Resolver {\n    function setName(bytes32 node, string name) public;\n}\n\n/**\n * @dev Provides a default implementation of a resolver for reverse records,\n * which permits only the owner to update it.\n */\ncontract DefaultReverseResolver is Resolver {\n    AbstractENS public ens;\n    mapping(bytes32=>string) public name;\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    function DefaultReverseResolver(AbstractENS ensAddr) {\n        ens = ensAddr;\n    }\n\n    /**\n     * @dev Only permits calls by the reverse registrar.\n     * @param node The node permission is required for.\n     */\n    modifier owner_only(bytes32 node) {\n        require(msg.sender == ens.owner(node));\n        _;\n    }\n\n    /**\n     * @dev Sets the name for a node.\n     * @param node The node to update.\n     * @param _name The name to set.\n     */\n    function setName(bytes32 node, string _name) public owner_only(node) {\n        name[node] = _name;\n    }\n}\n\ncontract ReverseRegistrar {\n    // namehash('addr.reverse')\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    AbstractENS public ens;\n    Resolver public defaultResolver;\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     * @param resolverAddr The address of the default reverse resolver.\n     */\n    function ReverseRegistrar(AbstractENS ensAddr, Resolver resolverAddr) {\n        ens = ensAddr;\n        defaultResolver = resolverAddr;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) returns (bytes32 node) {\n        return claimWithResolver(owner, 0);\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver) returns (bytes32 node) {\n        var label = sha3HexAddress(msg.sender);\n        node = sha3(ADDR_REVERSE_NODE, label);\n        var currentOwner = ens.owner(node);\n\n        // Update the resolver if required\n        if(resolver != 0 && resolver != ens.resolver(node)) {\n            // Transfer the name to us first if it's not already\n            if(currentOwner != address(this)) {\n                ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, this);\n                currentOwner = address(this);\n            }\n            ens.setResolver(node, resolver);\n        }\n\n        // Update the owner if required\n        if(currentOwner != owner) {\n            ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n        }\n\n        return node;\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string name) returns (bytes32 node) {\n        node = claimWithResolver(this, defaultResolver);\n        defaultResolver.setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) constant returns (bytes32 ret) {\n        return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr));\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private returns (bytes32 ret) {\n        addr; ret; // Stop warning us about unused variables\n        assembly {\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n            let i := 40\n        loop:\n            i := sub(i, 1)\n            mstore8(i, byte(and(addr, 0xf), lookup))\n            addr := div(addr, 0x10)\n            i := sub(i, 1)\n            mstore8(i, byte(and(addr, 0xf), lookup))\n            addr := div(addr, 0x10)\n            jumpi(loop, i)\n            ret := sha3(0, 40)\n        }\n    }\n}\n",children:(0,s.jsx)(n.code,{children:"pragma solidity ^0.4.10;\n\nimport \"./AbstractENS.sol\";\n\ncontract Resolver {\n    function setName(bytes32 node, string name) public;\n}\n\n/**\n * @dev Provides a default implementation of a resolver for reverse records,\n * which permits only the owner to update it.\n */\ncontract DefaultReverseResolver is Resolver {\n    AbstractENS public ens;\n    mapping(bytes32=>string) public name;\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    function DefaultReverseResolver(AbstractENS ensAddr) {\n        ens = ensAddr;\n    }\n\n    /**\n     * @dev Only permits calls by the reverse registrar.\n     * @param node The node permission is required for.\n     */\n    modifier owner_only(bytes32 node) {\n        require(msg.sender == ens.owner(node));\n        _;\n    }\n\n    /**\n     * @dev Sets the name for a node.\n     * @param node The node to update.\n     * @param _name The name to set.\n     */\n    function setName(bytes32 node, string _name) public owner_only(node) {\n        name[node] = _name;\n    }\n}\n\ncontract ReverseRegistrar {\n    // namehash('addr.reverse')\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    AbstractENS public ens;\n    Resolver public defaultResolver;\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     * @param resolverAddr The address of the default reverse resolver.\n     */\n    function ReverseRegistrar(AbstractENS ensAddr, Resolver resolverAddr) {\n        ens = ensAddr;\n        defaultResolver = resolverAddr;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) returns (bytes32 node) {\n        return claimWithResolver(owner, 0);\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver) returns (bytes32 node) {\n        var label = sha3HexAddress(msg.sender);\n        node = sha3(ADDR_REVERSE_NODE, label);\n        var currentOwner = ens.owner(node);\n\n        // Update the resolver if required\n        if(resolver != 0 && resolver != ens.resolver(node)) {\n            // Transfer the name to us first if it's not already\n            if(currentOwner != address(this)) {\n                ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, this);\n                currentOwner = address(this);\n            }\n            ens.setResolver(node, resolver);\n        }\n\n        // Update the owner if required\n        if(currentOwner != owner) {\n            ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n        }\n\n        return node;\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string name) returns (bytes32 node) {\n        node = claimWithResolver(this, defaultResolver);\n        defaultResolver.setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) constant returns (bytes32 ret) {\n        return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr));\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private returns (bytes32 ret) {\n        addr; ret; // Stop warning us about unused variables\n        assembly {\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n            let i := 40\n        loop:\n            i := sub(i, 1)\n            mstore8(i, byte(and(addr, 0xf), lookup))\n            addr := div(addr, 0x10)\n            i := sub(i, 1)\n            mstore8(i, byte(and(addr, 0xf), lookup))\n            addr := div(addr, 0x10)\n            jumpi(loop, i)\n            ret := sha3(0, 40)\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Copyright"}),"\n",(0,s.jsxs)(n.p,{children:["Copyright and related rights waived via ",(0,s.jsx)(n.a,{href:"https://creativecommons.org/publicdomain/zero/1.0/",children:"CC0"}),"."]})]})}var o=!0;n.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(a,e)})):a(e)}}},function(e){e.O(0,[9774,2888,179],function(){return e(e.s=7089)}),_N_E=e.O()}]);