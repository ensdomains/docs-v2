(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1703],{1929:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/ensip/10",function(){return r(514)}])},514:function(e,n,r){"use strict";r.r(n),r.d(n,{__N_SSG:function(){return o}});var t=r(1527),s=r(313);function i(e){let n=Object.assign({h1:"h1",table:"table",thead:"thead",tr:"tr",th:"th",strong:"strong",a:"a",tbody:"tbody",td:"td",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",pre:"pre",ol:"ol",em:"em",h3:"h3"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"ENSIP-10: Wildcard Resolution"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Author"})}),(0,t.jsxs)(n.th,{children:["Nick Johnson <",(0,t.jsx)(n.a,{href:"mailto:nick@ens.domains",children:"nick@ens.domains"}),">, 0age (@0age)"]})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Status"})}),(0,t.jsx)(n.td,{children:"Draft"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Submitted"})}),(0,t.jsx)(n.td,{children:"2020-02-28"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,t.jsx)(n.p,{children:'The Ethereum Name Service Specification (ENSIP-1) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated "node", and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record.'}),"\n",(0,t.jsx)(n.p,{children:"As currently specified, this process terminates if a resolver is not set on the ENS Registry for a given node. This ENSIP changes the name resolution process by adding an additional step if a resolver is not set for a domain. This step strips out the leftmost label from the name, derives the node of the new fragment, and supplies that node to the ENS Registry. If a resolver is located for that node, the client supplies the original, complete node to that resolver contract to derive the relevant records. This step is repeated until a node with a resolver is found."}),"\n",(0,t.jsxs)(n.p,{children:["Further, this specification defines a new way for resolvers to resolve names, using a unified ",(0,t.jsx)(n.code,{children:"resolve()"})," method that permits more flexible handling of name resolution."]}),"\n",(0,t.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(n.p,{children:"Many applications such as wallet providers, exchanges, and dapps have expressed a desire to issue ENS names for their users via custom subdomains on a shared parent domain. However, the cost of doing so is currently prohibitive for large user bases, as a distinct record must be set on the ENS Registry for each subdomain."}),"\n",(0,t.jsx)(n.p,{children:"Furthermore, users cannot immediately utilize these subdomains upon account creation, as the transaction to assign a resolver for the node of the subdomain must first be submitted and mined on-chain. This adds unnecessary friction when onboarding new users, who coincidentally would often benefit greatly from the usability improvements afforded by an ENS name."}),"\n",(0,t.jsxs)(n.p,{children:["Enabling wildcard support allows for the design of more advanced resolvers that deterministically generate addresses and other records for unassigned subdomains. The generated addresses could map to counterfactual contract deployment addresses (i.e. ",(0,t.jsx)(n.code,{children:"CREATE2"}),' addresses), to designated "fallback" addresses, or other schemes. Additionally, individual resolvers would still be assignable to any given subdomain, which would supersede the wildcard resolution using the parent resolver.']}),"\n",(0,t.jsx)(n.p,{children:"Another critical motivation with this standard is to enable wildcard resolution in a backwards-compatible fashion. It does not require modifying the current ENS Registry contract or any existing resolvers, and continues to support existing ENS records — legacy ENS clients would simply fail to resolve wildcard records."}),"\n",(0,t.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,t.jsx)(n.p,{children:"The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119."}),"\n",(0,t.jsx)(n.p,{children:"Let:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"namehash"})," be the algorithm defined in ENSIP-1."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dnsencode"})," be the process for encoding DNS names specified in section 3.1 of RFC1035, with the exception that there is no limit on the total length of the encoded name. The empty string is encoded identically to the name '.', as a single 0-octet."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"parent"})," be a function that removes the first label from a name (eg, ",(0,t.jsx)(n.code,{children:"parent('foo.eth') = 'eth'"}),"). ",(0,t.jsx)(n.code,{children:"parent('tld')"})," is defined as the empty string ''."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ens"})," is the ENS registry contract for the current network."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"ENSIP-10-compliant ENS resolvers MAY implement the following function interface:"}),"\n",(0,t.jsx)(n.pre,{code:"interface ExtendedResolver {\n    function resolve(bytes calldata name, bytes calldata data) external view returns(bytes);\n}\n",children:(0,t.jsx)(n.code,{children:"interface ExtendedResolver {\n    function resolve(bytes calldata name, bytes calldata data) external view returns(bytes);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If a resolver implements this function, it MUST return true when ",(0,t.jsx)(n.code,{children:"supportsInterface()"})," is called on it with the interface's ID, ",(0,t.jsx)(n.code,{children:"0x9061b923"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["ENS clients will call ",(0,t.jsx)(n.code,{children:"resolve"})," with the DNS-encoded name to resolve and the encoded calldata for a resolver function (as specified in ENSIP-1 and elsewhere); the function MUST either return valid return data for that function, or revert if it is not supported."]}),"\n",(0,t.jsx)(n.p,{children:"ENSIP-10-compliant ENS clients MUST perform the following procedure when determining the resolver for a given name:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"currentname = name"})]}),"\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"resolver = ens.resolver(namehash(currentname))"})]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"resolver"})," is not the zero address, halt and return ",(0,t.jsx)(n.code,{children:"resolver"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"currentname"})," is the empty name ('' or '.'), halt and return null."]}),"\n",(0,t.jsxs)(n.li,{children:["Otherwise, set ",(0,t.jsx)(n.code,{children:"currentname = parent(currentname)"})," and go to 2."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If the procedure above returns null, name resolution MUST terminate unsuccessfully. Otherwise, ENSIP-10-compliant ENS clients MUST perform the following procedure when resolving a record:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"calldata"})," to the ABI-encoded call data for the resolution function required - for example, the ABI encoding of ",(0,t.jsx)(n.code,{children:"addr(namehash(name))"})," when resolving the ",(0,t.jsx)(n.code,{children:"addr"})," record."]}),"\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"supportsENSIP10 = resolver.supportsInterface('0x9061b923')"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"supportsENSIP10"})," is true, set ",(0,t.jsx)(n.code,{children:"result = resolver.resolve(dnsencode(name), calldata)"})]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"supportsENSIP10"})," is false and ",(0,t.jsx)(n.code,{children:"name == currentname"}),", set ",(0,t.jsx)(n.code,{children:"result"})," to the result of calling ",(0,t.jsx)(n.code,{children:"resolver"})," with ",(0,t.jsx)(n.code,{children:"calldata"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"If neither 3 nor 4 are true, terminate unsuccessfully."}),"\n",(0,t.jsxs)(n.li,{children:["Return ",(0,t.jsx)(n.code,{children:"result"})," after decoding it using the return data ABI of the corresponding resolution function (eg, for ",(0,t.jsx)(n.code,{children:"addr()"}),", ABI-decode the result of ",(0,t.jsx)(n.code,{children:"resolver.resolve()"})," as an ",(0,t.jsx)(n.code,{children:"address"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that in all cases the resolution function (",(0,t.jsx)(n.code,{children:"addr()"})," etc) and the ",(0,t.jsx)(n.code,{children:"resolve"})," function are supplied the original ",(0,t.jsx)(n.code,{children:"name"}),", ",(0,t.jsx)(n.em,{children:"not"})," the ",(0,t.jsx)(n.code,{children:"currentname"})," found in the first stage of resolution."]}),"\n",(0,t.jsxs)(n.p,{children:["Also note that when wildcard resolution is in use (eg, ",(0,t.jsx)(n.code,{children:"name != currentname"}),"), clients MUST NOT call legacy methods such as ",(0,t.jsx)(n.code,{children:"addr"})," to resolve the name. These methods may only be called on resolvers set on an exact match for ",(0,t.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,t.jsx)(n.h3,{children:"Pseudocode"}),"\n",(0,t.jsx)(n.pre,{code:"function getResolver(name) {\n    for(let currentname = name; currentname !== ''; currentname = parent(currentname)) {\n        const node = namehash(currentname);\n        const resolver = ens.resolver(node);\n        if(resolver != '0x0000000000000000000000000000000000000000') {\n            return [resolver, currentname];\n        }\n    }\n    return [null, ''];\n}\n\nfunction resolve(name, func, ...args) {\n    const [resolver, resolverName] = getResolver(name);\n    if(resolver === null) {\n        return null;\n    }\n    const supportsENSIP10 = resolver.supportsInterface('0x9061b923');\n    if(supportsENSIP10) {\n        const calldata = resolver[func].encodeFunctionCall(namehash(name), ...args);\n        const result = resolver.resolve(dnsencode(name), calldata);\n        return resolver[func].decodeReturnData(result);\n    } else if(name == resolverName) {\n        return resolver[func](...args);\n    } else {\n        return null;\n    }\n}\n",children:(0,t.jsx)(n.code,{children:"function getResolver(name) {\n    for(let currentname = name; currentname !== ''; currentname = parent(currentname)) {\n        const node = namehash(currentname);\n        const resolver = ens.resolver(node);\n        if(resolver != '0x0000000000000000000000000000000000000000') {\n            return [resolver, currentname];\n        }\n    }\n    return [null, ''];\n}\n\nfunction resolve(name, func, ...args) {\n    const [resolver, resolverName] = getResolver(name);\n    if(resolver === null) {\n        return null;\n    }\n    const supportsENSIP10 = resolver.supportsInterface('0x9061b923');\n    if(supportsENSIP10) {\n        const calldata = resolver[func].encodeFunctionCall(namehash(name), ...args);\n        const result = resolver.resolve(dnsencode(name), calldata);\n        return resolver[func].decodeReturnData(result);\n    } else if(name == resolverName) {\n        return resolver[func](...args);\n    } else {\n        return null;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(n.p,{children:"The proposed implementation supports wildcard resolution in a manner that minimizes the impact to existing systems. It also reuses existing algorithms and procedures to the greatest possible extent, thereby easing the burden placed on authors and maintainers of various ENS clients."}),"\n",(0,t.jsx)(n.p,{children:"It also recognizes an existing consensus concerning the desirability of wildcard resolution for ENS, enabling more widespread adoption of the original specification by solving for a key scalability obstacle."}),"\n",(0,t.jsxs)(n.p,{children:["While introducing an optional ",(0,t.jsx)(n.code,{children:"resolve"})," function for resolvers, taking the unhashed name and calldata for a resolution function increases implementation complexity, it provides a means for resolvers to obtain plaintext labels and act accordingly, which enables many wildcard-related use-cases that would otherwise not be possible - for example, a wildcard resolver could resolve ",(0,t.jsx)(n.code,{children:"id.nifty.eth"})," to the owner of the NFT with id ",(0,t.jsx)(n.code,{children:"id"})," in some collection. With only namehashes to work with, this is not possible."]}),"\n",(0,t.jsx)(n.p,{children:"The DNS wire format is used for encoding names as it permits quick and gas-efficient hashing of names, as well as other common operations such as fetching or removing individual labels; in contrast, dot-separated names require iterating over every character in the name to find the delimiter."}),"\n",(0,t.jsx)(n.h2,{id:"backwards-compatibility",children:"Backwards Compatibility"}),"\n",(0,t.jsxs)(n.p,{children:["Existing ENS clients that are compliant with ENSIP-1 will fail to resolve wildcard records and refuse to interact with them, while those compliant with ENSIP-10 will continue to correctly resolve, or reject, existing ENS records. Resolvers wishing to implement the new ",(0,t.jsx)(n.code,{children:"resolve"})," function for non-wildcard use-cases (eg, where the resolver is set directly on the name being resolved) should consider what to return to legacy clients that call the individual resolution functions for maximum compatibility."]}),"\n",(0,t.jsxs)(n.p,{children:["Requiring clients to avoid calling existing resolution functions (eg, ",(0,t.jsx)(n.code,{children:"addr"})," etc) on wildcard resolvers prevents inadvertant backwards compatiability issues with resolvers that answer queries for all names."]}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsx)(n.p,{children:"While compliant ENS clients will continue to refuse to resolve records without a resolver, there is still the risk that an improperly-configured client will refer to an incorrect resolver, or will not reject interactions with the null address when a resolver cannot be located."}),"\n",(0,t.jsx)(n.p,{children:"Additionally, resolvers supporting completely arbitrary wildcard subdomain resolution will increase the likelihood of funds being sent to unintended recipients as a result of typos. Applications that implement such resolvers should consider making additional name validation available to clients depending on the context, or implementing features that support recoverability of funds."}),"\n",(0,t.jsx)(n.p,{children:"There is also the possibility that some applications might require that no resolver be set for certain subdomains. For this to be problematic, the parent domain would need to successfully resolve the given subdomain node — to the knowledge of the authors, no application currently supports this feature or expects that subdomains should not resolve to a record."}),"\n",(0,t.jsx)(n.h2,{id:"copyright",children:"Copyright"}),"\n",(0,t.jsxs)(n.p,{children:["Copyright and related rights waived via ",(0,t.jsx)(n.a,{href:"https://creativecommons.org/publicdomain/zero/1.0/",children:"CC0"}),"."]})]})}var o=!0;n.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(i,e)})):i(e)}}},function(e){e.O(0,[9774,2888,179],function(){return e(e.s=1929)}),_N_E=e.O()}]);