(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[86],{7617:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/ensip/4",function(){return t(9186)}])},9186:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return o}});var s=t(1527),i=t(313);function r(e){let n=Object.assign({p:"p",h1:"h1",table:"table",thead:"thead",tr:"tr",th:"th",strong:"strong",a:"a",tbody:"tbody",td:"td",h2:"h2",h3:"h3",pre:"pre",code:"code"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205)."}),"\n",(0,s.jsx)(n.h1,{children:"ENSIP-4: Support for contract ABIs"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Author"})}),(0,s.jsxs)(n.th,{children:["Nick Johnson <",(0,s.jsx)(n.a,{href:"mailto:nick@ens.domains",children:"nick@ens.domains"}),">"]})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Status"})}),(0,s.jsx)(n.td,{children:"Final"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Submitted"})}),(0,s.jsx)(n.td,{children:"2017-02-06"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,s.jsx)(n.p,{children:"ABIs are important metadata required for interacting with most contracts. At present, they are typically supplied out-of-band, which adds an additional burden to interacting with contracts, particularly on a one-off basis or where the ABI may be updated over time. The small size of ABIs permits an alternative solution, storing them in ENS, permitting name lookup and ABI discovery via the same process."}),"\n",(0,s.jsx)(n.p,{children:"ABIs are typically quite compact; the largest in-use ABI we could find, that for the DAO, is 9450 bytes uncompressed JSON, 6920 bytes uncompressed CBOR, and 1128 bytes when the JSON form is compressed with zlib. Further gains on CBOR encoding are possible using a CBOR extension that permits eliminating repeated strings, which feature extensively in ABIs. Most ABIs, however, are far shorter than this, consisting of only a few hundred bytes of uncompressed JSON."}),"\n",(0,s.jsx)(n.p,{children:"This ENSIP defines a resolver profile for retrieving contract ABIs, as well as encoding standards for storing ABIs for different applications, allowing the user to select between different representations based on their need for compactness and other considerations such as onchain access."}),"\n",(0,s.jsx)(n.h2,{id:"specification",children:"Specification"}),"\n",(0,s.jsx)(n.h3,{children:"ABI encodings"}),"\n",(0,s.jsx)(n.p,{children:"In order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint."}),"\n",(0,s.jsx)(n.p,{children:"The currently recognised encodings are:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"ID"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"JSON"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"zlib-compressed JSON"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"CBOR"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"URI"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This table may be extended in future through the ENSIP process."}),"\n",(0,s.jsx)(n.p,{children:"Encoding type 1 specifies plaintext JSON, uncompressed; this is the standard format in which ABIs are typically encoded, but also the bulkiest, and is not easily parseable onchain."}),"\n",(0,s.jsx)(n.p,{children:"Encoding type 2 specifies zlib-compressed JSON. This is significantly smaller than uncompressed JSON, and is straightforward to decode offchain. However, it is impractical for onchain consumers to use."}),"\n",(0,s.jsxs)(n.p,{children:["Encoding type 4 is ",(0,s.jsx)(n.a,{href:"https://cbor.io",children:"CBOR"}),". CBOR is a binary encoding format that is a superset of JSON, and is both more compact and easier to parse in limited environments such as the EVM. Consumers that support CBOR are strongly encouraged to also support the ",(0,s.jsx)(n.a,{href:"http://cbor.schmorp.de/stringref",children:"stringref extension"})," to CBOR, which provides significant additional reduction in encoded size."]}),"\n",(0,s.jsx)(n.p,{children:"Encoding type 8 indicates that the ABI can be found elsewhere, at the specified URI. This is typically the most compact of the supported forms, but also adds external dependencies for implementers. The specified URI may use any schema, but HTTP, IPFS, and Swarm are expected to be the most common."}),"\n",(0,s.jsx)(n.h3,{children:"Resolver profile"}),"\n",(0,s.jsx)(n.p,{children:"A new resolver interface is defined, consisting of the following method:"}),"\n",(0,s.jsx)(n.pre,{code:"function ABI(bytes32 node, uint256 contentType) constant returns (uint256, bytes);\n",children:(0,s.jsx)(n.code,{children:"function ABI(bytes32 node, uint256 contentType) constant returns (uint256, bytes);\n"})}),"\n",(0,s.jsx)(n.p,{children:"The interface ID of this interface is 0x2203ab56."}),"\n",(0,s.jsxs)(n.p,{children:["contentType is a bitfield, and is the bitwise OR of all the encoding types the caller will accept. Resolvers that implement this interface must return an ABI encoded using one of the requested formats, or ",(0,s.jsx)(n.code,{children:'(0, "")'})," if they do not have an ABI for this function, or do not support any of the requested formats."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"abi"})," resolver profile is valid on both forward and reverse records."]}),"\n",(0,s.jsx)(n.h3,{children:"ABI lookup process"}),"\n",(0,s.jsx)(n.p,{children:"When attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to."}),"\n",(0,s.jsx)(n.p,{children:"Implementers should support as many of the ABI encoding formats as practical."}),"\n",(0,s.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,s.jsx)(n.p,{children:"Storing ABIs onchain avoids the need to introduce additional dependencies for applications wishing to fetch them, such as swarm or HTTP access. Given the typical compactness of ABIs, we believe this is a worthwhile tradeoff in many cases."}),"\n",(0,s.jsx)(n.p,{children:"The two-step resolution process permits different names to provide different ABIs for the same contract, such as in the case where it's useful to provide a minimal ABI to some callers, as well as specifying ABIs for contracts that did not specify one of their own. The fallback to looking up an ABI on the reverse record permits contracts to specify their own canonical ABI, and prevents the need for duplication when multiple names reference the same contract without the need for different ABIs."}),"\n",(0,s.jsx)(n.h2,{id:"copyright",children:"Copyright"}),"\n",(0,s.jsxs)(n.p,{children:["Copyright and related rights waived via ",(0,s.jsx)(n.a,{href:"https://creativecommons.org/publicdomain/zero/1.0/",children:"CC0"}),"."]})]})}var o=!0;n.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(r,e)})):r(e)}}},function(e){e.O(0,[774,888,179],function(){return e(e.s=7617)}),_N_E=e.O()}]);