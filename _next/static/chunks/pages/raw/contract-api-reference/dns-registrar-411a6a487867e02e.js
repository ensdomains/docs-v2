(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[904],{2023:function(e,r,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/raw/contract-api-reference/dns-registrar",function(){return n(5851)}])},5851:function(e,r,n){"use strict";n.r(r);var t=n(4637),a=n(6988),o=n(1177),s=n(9577),i=function(e){return(0,o.withSSG)((0,a.Z)({filename:"dns-registrar.mdx",route:"/raw/contract-api-reference/dns-registrar",meta:{},pageMap:[{name:"developer",children:[{name:"basics",route:"/developer/basics"},{name:"getting-started",route:"/developer/getting-started"},{name:"index",route:"/developer"},{name:"meta.json",meta:{index:{title:"Developer Documentation",type:"docs",theme:{}},"getting-started":{title:"Getting Started",type:"docs"},basics:{title:"Basics",type:"docs"},"working-directly-with-ens":{title:"Manual Contract API",type:"docs"}},locale:"en-US"},{name:"working-directly-with-ens",route:"/developer/working-directly-with-ens"}],route:"/developer"},{name:"governance",children:[{name:"index",route:"/governance"},{name:"meta.json",meta:{index:{title:"Governance Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/governance"},{name:"index",route:"/",frontMatter:{title:"Welcome"}},{name:"meta.json",meta:{index:{title:"Introduction",type:"docs",hidden:!0,theme:{}},about:{title:"About ENS",type:"docs",hidden:!0,theme:{}},user:{title:"User",type:"nav"},developer:{title:"Developer",type:"nav"},technical:{title:"Technical",type:"nav"},governance:{title:"Governance",type:"nav"},raw:{title:"Raw",type:"hidden"}},locale:"en-US"},{name:"raw",children:[{name:"SUMMARY",route:"/raw/SUMMARY"},{name:"bug-bounty-program",route:"/raw/bug-bounty-program"},{name:"contract-api-reference",children:[{name:"ENS-Contracts-Overview",route:"/raw/contract-api-reference/ENS-Contracts-Overview"},{name:"dns-registrar",route:"/raw/contract-api-reference/dns-registrar"},{name:"ens",route:"/raw/contract-api-reference/ens",frontMatter:{description:"The ENS registry."}},{name:"eth-permanent-registrar",children:[{name:"README",route:"/raw/contract-api-reference/eth-permanent-registrar/README"},{name:"controller",route:"/raw/contract-api-reference/eth-permanent-registrar/controller"},{name:"registrar",route:"/raw/contract-api-reference/eth-permanent-registrar/registrar"}],route:"/raw/contract-api-reference/eth-permanent-registrar"},{name:"name-processing",route:"/raw/contract-api-reference/name-processing",frontMatter:{description:"Describes how to normalize and hash ENS names."}},{name:"publicresolver",route:"/raw/contract-api-reference/publicresolver",frontMatter:{description:"The default public resolver."}},{name:"reverseregistrar",route:"/raw/contract-api-reference/reverseregistrar",frontMatter:{description:"The registrar responsible for managing reverse resolution via the .addr.reverse special-purpose TLD."}},{name:"testregistrar",route:"/raw/contract-api-reference/testregistrar"}],route:"/raw/contract-api-reference"},{name:"contract-developer-guide",children:[{name:"resolving-names-on-chain",route:"/raw/contract-developer-guide/resolving-names-on-chain"},{name:"writing-a-registrar",route:"/raw/contract-developer-guide/writing-a-registrar"},{name:"writing-a-resolver",route:"/raw/contract-developer-guide/writing-a-resolver"}],route:"/raw/contract-developer-guide"},{name:"dapp-developer-guide",children:[{name:"ens-as-nft",route:"/raw/dapp-developer-guide/ens-as-nft"},{name:"ens-l2-offchain",route:"/raw/dapp-developer-guide/ens-l2-offchain"},{name:"front-end-design-guidelines",route:"/raw/dapp-developer-guide/front-end-design-guidelines",frontMatter:{description:"ENS is a tool to simplify the experience for your users. Here are a series of guidelines and tools that will help you make design choices and implement the best ENS user experience."}},{name:"managing-names",route:"/raw/dapp-developer-guide/managing-names"},{name:"registering-and-renewing-names",route:"/raw/dapp-developer-guide/registering-and-renewing-names"},{name:"resolving-names",route:"/raw/dapp-developer-guide/resolving-names"}],route:"/raw/dapp-developer-guide"},{name:"deploying-ens-on-a-private-chain",route:"/raw/deploying-ens-on-a-private-chain"},{name:"dns-registrar-guide",route:"/raw/dns-registrar-guide"},{name:"ens-deployments",route:"/raw/ens-deployments"},{name:"ens-improvement-proposals",children:[{name:"README",route:"/raw/ens-improvement-proposals/README",frontMatter:{description:"Standards documentation describing the ENS protocol"}},{name:"ensip-1-ens",route:"/raw/ens-improvement-proposals/ensip-1-ens",frontMatter:{description:"Documentation of the basic ENS protocol (formerly EIP-137)."}},{name:"ensip-10-wildcard-resolution",route:"/raw/ens-improvement-proposals/ensip-10-wildcard-resolution",frontMatter:{description:"Provides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544)."}},{name:"ensip-11-evmchain-address-resolution",route:"/raw/ens-improvement-proposals/ensip-11-evmchain-address-resolution",frontMatter:{description:"Introduces coinType for EVM compatible chains (amending ENSIP9)."}},{name:"ensip-12-avatar-text-records",route:"/raw/ens-improvement-proposals/ensip-12-avatar-text-records",frontMatter:{description:"A standard for storage of the avatar text record in ENS."}},{name:"ensip-2-initial-hash-registrar",route:"/raw/ens-improvement-proposals/ensip-2-initial-hash-registrar",frontMatter:{description:"Describes the hash registrar initially used to register ENS .eth domains (formerly EIP-162)."}},{name:"ensip-3-reverse-resolution",route:"/raw/ens-improvement-proposals/ensip-3-reverse-resolution",frontMatter:{description:"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181)."}},{name:"ensip-4-support-for-contract-abis",route:"/raw/ens-improvement-proposals/ensip-4-support-for-contract-abis",frontMatter:{description:"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205)."}},{name:"ensip-5-text-records",route:"/raw/ens-improvement-proposals/ensip-5-text-records",frontMatter:{description:"A standard for storage of text records in ENS (formerly EIP-634)."}},{name:"ensip-6-dns-in-ens",route:"/raw/ens-improvement-proposals/ensip-6-dns-in-ens",frontMatter:{description:"Defines a resolver profile for ENS that provides features for storage and lookup of DNS records (formerly EIP-1185)."}},{name:"ensip-7-contenthash-field",route:"/raw/ens-improvement-proposals/ensip-7-contenthash-field",frontMatter:{description:"Introduces a field for storing content addresses and hashes in ENS (formerly EIP-1577)."}},{name:"ensip-8-interface-discovery",route:"/raw/ens-improvement-proposals/ensip-8-interface-discovery",frontMatter:{description:"Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces (formerly EIP-1844)."}},{name:"ensip-9-multichain-address-resolution",route:"/raw/ens-improvement-proposals/ensip-9-multichain-address-resolution",frontMatter:{description:"Introduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS (formerly EIP-2304)."}}],route:"/raw/ens-improvement-proposals"},{name:"ens-migration-february-2020",children:[{name:"guide-for-dapp-developers",route:"/raw/ens-migration-february-2020/guide-for-dapp-developers"},{name:"technical-description",route:"/raw/ens-migration-february-2020/technical-description"}],route:"/raw/ens-migration-february-2020"},{name:"frequently-asked-questions",route:"/raw/frequently-asked-questions"},{name:"permanent-registrar-faq",route:"/raw/permanent-registrar-faq"},{name:"terminology",route:"/raw/terminology"}],route:"/raw"},{name:"technical",children:[{name:"about",route:"/technical/about"},{name:"index",route:"/technical"},{name:"meta.json",meta:{index:{title:"Technical Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/technical"},{name:"user",children:[{name:"index",route:"/user"},{name:"meta.json",meta:{index:{title:"User Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/user"}]},s.Z))(e)};function c(e){var r=Object.assign({h1:"h1",p:"p",a:"a",img:"img",h2:"h2",ul:"ul",li:"li",code:"code",h3:"h3",pre:"pre"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"DNS Registrar"}),"\n",(0,t.jsxs)(r.p,{children:["At ENS, we have two smart contracts, ",(0,t.jsx)(r.a,{href:"https://github.com/ensdomains/dnssec-oracle",children:"DNSSECOracle"})," and ",(0,t.jsx)(r.a,{href:"https://github.com/ensdomains/dnsregistrar",children:"DNSRegistrar"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"DNSSEC (The Domain Name System Security Extensions) establishes a chain of trust from the root key which is signed by ICANN (.) and down through each key. We start off knowing the hash of the root key of DNS (this is hard coded in the smart contract oracle). Given the hashes of that key, we can pass in the actual key, we can verify that it matches the hash and we can add it to the set of the trusted records."}),"\n",(0,t.jsx)(r.p,{children:"Given that key, we can now verify any record that is signed with that key, so in this case, it's the hash of the root of the xyz top-level domain. Given that, we can recognize the key, and so on and so forth."}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:"../../public/assets/diagram.png",alt:"DNSSEC Diagram"})}),"\n",(0,t.jsx)(r.p,{children:"DNSSEC oracle allows anyone to submit proof of any DNSSEC-signed DNS record on the Ethereum blockchain, as long as it was signed using supported public key schemes and digests. DNSRegistrar grants ENS domains to anyone who can prove ownership of the corresponding domain in DNS through DNSSEC Oracle to prove this."}),"\n",(0,t.jsx)(r.h2,{children:"Deployed DNSRegistrar addresses"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Mainnet, at TBD."}),"\n",(0,t.jsx)(r.li,{children:"Ropsten, at 0x475e527d54b91b0b011DA573C69Ac54B2eC269ea."}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["When you register ENS names, you can look up the registrar contract address by looking up its parent domain owner (eg: ",(0,t.jsx)(r.code,{children:".eth"}),", for ",(0,t.jsx)(r.code,{children:".matoken.eth"}),"). However, when you register via DNSSEC Registrars, the parent domain owner may not exist if you are the first person to register under the TLD."]}),"\n",(0,t.jsx)(r.h2,{children:"Gas cost"}),"\n",(0,t.jsxs)(r.p,{children:["Submitting proof to DNSSEC Oracle takes up a lot of gas because it is heavy computation work. It will take up even more gas if you submit the first domain under the specific TLD. This is because it submits proof of both your domain and its parent domain(eg: ",(0,t.jsx)(r.code,{children:"matoken.live"}),", as well as ",(0,t.jsx)(r.code,{children:".live"}),"). When tested on Ropsten network, ",(0,t.jsx)(r.a,{href:"https://ropsten.etherscan.io/tx/0x7ba91728530b2a9f325b330986265fd455639fd3f07e775cf68ee8c767b2637f",children:"it cost 1,663,953 gas"})]}),"\n",(0,t.jsx)(r.h2,{children:"Typescript/Javascript Libraries"}),"\n",(0,t.jsx)(r.p,{children:"To help you interact with DNSSEC data and the DNSRegistrar, we provide two libraries."}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"https://github.com/ensdomains/dnsprovejs",children:"DNSProvejs"})," = A library for querying and validating DNSSEC data from DNS"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"https://github.com/ensdomains/dnssecoraclejs",children:"dnssecoraclejs"})," = A library for generating proof data for the ENS DNSSEC Oracle."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"Examples"}),"\n",(0,t.jsx)(r.h3,{children:"Retrieving proof from DNS"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"import { Oracle } from '@ensdomains/dnssecoraclejs'\nimport { DNSProver } from '@ensdomains/dnsprovejs'\n\nconst textDomain = '_ens.matoken.xyz'\nconst prover = DNSProver.create(\"https://cloudflare-dns.com/dns-query\")\nconst result = await prover.queryWithProof('TXT', textDomain)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Retrieving the DNS text record"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"const result = {\n  answer: SignedSet {\n    records: [{\n      name: '_ens.matoken.xyz',\n      type: 'TXT',\n      ttl: 300,\n      class: 'IN',\n      flush: false,\n      data: [Array]\n    }],\n    signature: {\n      name: '_ens.matoken.xyz',\n      type: 'RRSIG',\n      ttl: 300,\n      class: 'IN',\n      flush: false,\n      data: [Object]\n    }\n  },\n  proofs: [\n    SignedSet { records: [Array], signature: [Object] },\n    SignedSet { records: [Array], signature: [Object] },\n    SignedSet { records: [Array], signature: [Object] },\n    SignedSet { records: [Array], signature: [Object] },\n    SignedSet { records: [Array], signature: [Object] }\n  ]\n}\n\n// Retrieving the text record\nresult.answer.records[0].data.toString()\n// 'a=0xa5313060f9fa6b607ac8ca8728a851166c9f612'\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"queryWithProof"})," returns ",(0,t.jsx)(r.code,{children:"answer"})," and ",(0,t.jsx)(r.code,{children:"proofs"}),". ",(0,t.jsx)(r.code,{children:"answer"})," contains the human-readable record of the DNS record and its signing signature (RRSIG). The example above shows that the leaf of the chain (the first returned record) contains the ",(0,t.jsx)(r.code,{children:"TXT"})," record type in ",(0,t.jsx)(r.code,{children:"a=$ETHEREUM_ADDRESS"})," format."]}),"\n",(0,t.jsx)(r.h3,{children:"Submitting the proof to the DNSRegistrar"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"import { Oracle } from '@ensdomains/dnssecoraclejs'\nimport { abi } from '@ensdomains/contracts/abis/dnsregistrar/DNSRegistrar.json'\nimport { Contract } from 'ethers'\n\n// The registrar address nees to be hard-coded\nconst registrarAddress = '0x475e527d54b91b0b011DA573C69Ac54B2eC269ea'\nconst registrar new Contract(registrarAddress, abi, provider)\nconst oracleAddress = await registrar.oracle()\nconst oracle = new Oracle(oracleAddress, provider)\nconst { data, proof } = oracle.getProofData(result)\n\nif(data.length === 0){\n    // This happens if someone has submitted the proof directly to DNSSECOracle, hence only claim a name on the registrar.\n    return registrar.claim(claim.encodedName, proof)\n}else{\n    // This submits proof to DNSSECOracle, then claim a name.\n    return registrar.proveAndClaim(claim.encodedName, data, proof)\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Todo"}),"\n",(0,t.jsx)(r.p,{children:"It is currently missing the Typescript/JS library support to delete the record from DNSSECOracle by providing NSEC/NSEC3(Next Secure Record) proof."})]})}r.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,t.jsx)(i,Object.assign({},e,{children:(0,t.jsx)(c,e)}))}}},function(e){e.O(0,[4698,9214,9774,2888,179],(function(){return r=2023,e(e.s=r);var r}));var r=e.O();_N_E=r}]);