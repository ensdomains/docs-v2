(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1996],{4539:function(e,r,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/raw/contract-api-reference/name-processing",function(){return n(8093)}])},8093:function(e,r,n){"use strict";n.r(r);var a=n(4637),t=n(6988),i=n(1177),s=n(9577),o=function(e){return(0,i.withSSG)((0,t.Z)({filename:"name-processing.mdx",route:"/raw/contract-api-reference/name-processing",meta:{description:"Describes how to normalize and hash ENS names."},pageMap:[{name:"developer",children:[{name:"basics",route:"/developer/basics"},{name:"getting-started",route:"/developer/getting-started"},{name:"index",route:"/developer"},{name:"meta.json",meta:{index:{title:"Developer Documentation",type:"docs",theme:{}},"getting-started":{title:"Getting Started",type:"docs"},basics:{title:"Basics",type:"docs"},"working-directly-with-ens":{title:"Manual Contract API",type:"docs"}},locale:"en-US"},{name:"working-directly-with-ens",route:"/developer/working-directly-with-ens"}],route:"/developer"},{name:"governance",children:[{name:"index",route:"/governance"},{name:"meta.json",meta:{index:{title:"Governance Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/governance"},{name:"index",route:"/",frontMatter:{title:"Welcome"}},{name:"meta.json",meta:{index:{title:"Introduction",type:"docs",hidden:!0,theme:{}},about:{title:"About ENS",type:"docs",hidden:!0,theme:{}},user:{title:"User",type:"nav"},developer:{title:"Developer",type:"nav"},technical:{title:"Technical",type:"nav"},governance:{title:"Governance",type:"nav"},raw:{title:"Raw",type:"hidden"}},locale:"en-US"},{name:"raw",children:[{name:"SUMMARY",route:"/raw/SUMMARY"},{name:"bug-bounty-program",route:"/raw/bug-bounty-program"},{name:"contract-api-reference",children:[{name:"ENS-Contracts-Overview",route:"/raw/contract-api-reference/ENS-Contracts-Overview"},{name:"dns-registrar",route:"/raw/contract-api-reference/dns-registrar"},{name:"ens",route:"/raw/contract-api-reference/ens",frontMatter:{description:"The ENS registry."}},{name:"eth-permanent-registrar",children:[{name:"README",route:"/raw/contract-api-reference/eth-permanent-registrar/README"},{name:"controller",route:"/raw/contract-api-reference/eth-permanent-registrar/controller"},{name:"registrar",route:"/raw/contract-api-reference/eth-permanent-registrar/registrar"}],route:"/raw/contract-api-reference/eth-permanent-registrar"},{name:"name-processing",route:"/raw/contract-api-reference/name-processing",frontMatter:{description:"Describes how to normalize and hash ENS names."}},{name:"publicresolver",route:"/raw/contract-api-reference/publicresolver",frontMatter:{description:"The default public resolver."}},{name:"reverseregistrar",route:"/raw/contract-api-reference/reverseregistrar",frontMatter:{description:"The registrar responsible for managing reverse resolution via the .addr.reverse special-purpose TLD."}},{name:"testregistrar",route:"/raw/contract-api-reference/testregistrar"}],route:"/raw/contract-api-reference"},{name:"contract-developer-guide",children:[{name:"resolving-names-on-chain",route:"/raw/contract-developer-guide/resolving-names-on-chain"},{name:"writing-a-registrar",route:"/raw/contract-developer-guide/writing-a-registrar"},{name:"writing-a-resolver",route:"/raw/contract-developer-guide/writing-a-resolver"}],route:"/raw/contract-developer-guide"},{name:"dapp-developer-guide",children:[{name:"ens-as-nft",route:"/raw/dapp-developer-guide/ens-as-nft"},{name:"ens-l2-offchain",route:"/raw/dapp-developer-guide/ens-l2-offchain"},{name:"front-end-design-guidelines",route:"/raw/dapp-developer-guide/front-end-design-guidelines",frontMatter:{description:"ENS is a tool to simplify the experience for your users. Here are a series of guidelines and tools that will help you make design choices and implement the best ENS user experience."}},{name:"managing-names",route:"/raw/dapp-developer-guide/managing-names"},{name:"registering-and-renewing-names",route:"/raw/dapp-developer-guide/registering-and-renewing-names"},{name:"resolving-names",route:"/raw/dapp-developer-guide/resolving-names"}],route:"/raw/dapp-developer-guide"},{name:"deploying-ens-on-a-private-chain",route:"/raw/deploying-ens-on-a-private-chain"},{name:"dns-registrar-guide",route:"/raw/dns-registrar-guide"},{name:"ens-deployments",route:"/raw/ens-deployments"},{name:"ens-improvement-proposals",children:[{name:"README",route:"/raw/ens-improvement-proposals/README",frontMatter:{description:"Standards documentation describing the ENS protocol"}},{name:"ensip-1-ens",route:"/raw/ens-improvement-proposals/ensip-1-ens",frontMatter:{description:"Documentation of the basic ENS protocol (formerly EIP-137)."}},{name:"ensip-10-wildcard-resolution",route:"/raw/ens-improvement-proposals/ensip-10-wildcard-resolution",frontMatter:{description:"Provides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544)."}},{name:"ensip-11-evmchain-address-resolution",route:"/raw/ens-improvement-proposals/ensip-11-evmchain-address-resolution",frontMatter:{description:"Introduces coinType for EVM compatible chains (amending ENSIP9)."}},{name:"ensip-12-avatar-text-records",route:"/raw/ens-improvement-proposals/ensip-12-avatar-text-records",frontMatter:{description:"A standard for storage of the avatar text record in ENS."}},{name:"ensip-2-initial-hash-registrar",route:"/raw/ens-improvement-proposals/ensip-2-initial-hash-registrar",frontMatter:{description:"Describes the hash registrar initially used to register ENS .eth domains (formerly EIP-162)."}},{name:"ensip-3-reverse-resolution",route:"/raw/ens-improvement-proposals/ensip-3-reverse-resolution",frontMatter:{description:"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181)."}},{name:"ensip-4-support-for-contract-abis",route:"/raw/ens-improvement-proposals/ensip-4-support-for-contract-abis",frontMatter:{description:"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205)."}},{name:"ensip-5-text-records",route:"/raw/ens-improvement-proposals/ensip-5-text-records",frontMatter:{description:"A standard for storage of text records in ENS (formerly EIP-634)."}},{name:"ensip-6-dns-in-ens",route:"/raw/ens-improvement-proposals/ensip-6-dns-in-ens",frontMatter:{description:"Defines a resolver profile for ENS that provides features for storage and lookup of DNS records (formerly EIP-1185)."}},{name:"ensip-7-contenthash-field",route:"/raw/ens-improvement-proposals/ensip-7-contenthash-field",frontMatter:{description:"Introduces a field for storing content addresses and hashes in ENS (formerly EIP-1577)."}},{name:"ensip-8-interface-discovery",route:"/raw/ens-improvement-proposals/ensip-8-interface-discovery",frontMatter:{description:"Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces (formerly EIP-1844)."}},{name:"ensip-9-multichain-address-resolution",route:"/raw/ens-improvement-proposals/ensip-9-multichain-address-resolution",frontMatter:{description:"Introduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS (formerly EIP-2304)."}}],route:"/raw/ens-improvement-proposals"},{name:"ens-migration-february-2020",children:[{name:"guide-for-dapp-developers",route:"/raw/ens-migration-february-2020/guide-for-dapp-developers"},{name:"technical-description",route:"/raw/ens-migration-february-2020/technical-description"}],route:"/raw/ens-migration-february-2020"},{name:"frequently-asked-questions",route:"/raw/frequently-asked-questions"},{name:"permanent-registrar-faq",route:"/raw/permanent-registrar-faq"},{name:"terminology",route:"/raw/terminology"}],route:"/raw"},{name:"technical",children:[{name:"about",route:"/technical/about"},{name:"index",route:"/technical"},{name:"meta.json",meta:{index:{title:"Technical Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/technical"},{name:"user",children:[{name:"index",route:"/user"},{name:"meta.json",meta:{index:{title:"User Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/user"}]},s.Z))(e)};function c(e){var r=Object.assign({h1:"h1",p:"p",em:"em",strong:"strong",h2:"h2",a:"a",h3:"h3",ul:"ul",li:"li",code:"code",pre:"pre"},e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h1,{children:"Name Processing"}),"\n",(0,a.jsxs)(r.p,{children:["In place of human-readable names, ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is ",(0,a.jsx)(r.em,{children:"0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec"}),"; this is the representation of names that is used exclusively inside ENS."]}),"\n",(0,a.jsxs)(r.p,{children:["Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name ",(0,a.jsx)(r.strong,{children:"must"})," first normalize it, to ensure that all users get a consistent view of ENS."]}),"\n",(0,a.jsx)(r.h2,{children:"Normalising Names"}),"\n",(0,a.jsxs)(r.p,{children:["Before a name can be converted to a node hash using Namehash, the name must first be normalized and checked for validity - for instance, converting ",(0,a.jsx)(r.em,{children:"fOO.eth"})," into ",(0,a.jsx)(r.em,{children:"foo.eth"}),", and prohibiting names containing forbidden characters such as underscores. It is crucial that all applications follow the same set of rules for normalization and validation, as otherwise two users entering the same name on different systems may resolve the same human-readable name into two different ENS names."]}),"\n",(0,a.jsxs)(r.p,{children:["Applications using ENS and processing human-readable names must follow ",(0,a.jsx)(r.a,{href:"http://unicode.org/reports/tr46/",children:"UTS46"})," for normalization and validation. Processing should be done with non-transitional rules, and with UseSTD3ASCIIRules=true."]}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.a,{href:"https://www.npmjs.com/package/@ensdomains/eth-ens-namehash",children:"eth-ens-namehash"})," Javascript library performs both normalization and hashing as described here. All of the ",(0,a.jsx)(r.a,{href:"../dapp-developer-guide/ens-libraries.md",children:"ENS libraries"})," covered in the DApp Developer Guide also perform normalization and hashing."]}),"\n",(0,a.jsx)(r.h2,{children:"Hashing Names"}),"\n",(0,a.jsx)(r.p,{children:"Namehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally."}),"\n",(0,a.jsx)(r.h3,{children:"Terminology"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["domain - The complete, human-readable form of a name; eg, ",(0,a.jsx)(r.em,{children:"iam.alice.eth"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:["label - A single component of a domain - eg, ",(0,a.jsx)(r.em,{children:"iam"}),", ",(0,a.jsx)(r.em,{children:"alice"}),", or ",(0,a.jsx)(r.em,{children:"eth"}),"."]}),"\n",(0,a.jsxs)(r.li,{children:["label hash - the output of the keccak-256 function applied to a label; eg, ",(0,a.jsx)(r.code,{children:"keccak256('eth') = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0"})]}),"\n",(0,a.jsxs)(r.li,{children:["node - The output of the ",(0,a.jsx)(r.code,{children:"namehash"})," function, used to uniquely identify a name in ENS."]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{children:"Algorithm"}),"\n",(0,a.jsx)(r.p,{children:"First, a domain is divided into labels by splitting on periods ('.'). So, 'vitalik.wallet.eth' becomes the list ['vitalik', 'wallet', 'eth']."}),"\n",(0,a.jsx)(r.p,{children:"The namehash function is then defined recursively as follows:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-text",children:"namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000\nnamehash([label, \u2026]) = keccak256(namehash(\u2026), keccak256(label))\n"})}),"\n",(0,a.jsx)(r.p,{children:"A sample implementation in Python is provided below."}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"def namehash(name):\n  if name == '':\n    return '\\0' * 32\n  else:\n    label, _, remainder = name.partition('.')\n    return sha3(namehash(remainder) + sha3(label))\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Namehash is specified in ",(0,a.jsx)(r.a,{href:"https://eips.ethereum.org/EIPS/eip-137",children:"EIP 137"}),"."]}),"\n",(0,a.jsx)(r.h3,{children:"How do I find the labelhash/namehash of a name?"}),"\n",(0,a.jsxs)(r.p,{children:["In some cases, you may need to know the hash of the name stored in ENS. labelhash means hash of the label of the domain (eg: ",(0,a.jsx)(r.code,{children:"makoto"})," for ",(0,a.jsx)(r.code,{children:"makoto.eth"}),") and namehash is the hash which combines labelhashes. We are currently working to include this information in our Manager app. In the meantime, you can query the information via ",(0,a.jsx)(r.a,{href:"https://thegraph.com/explorer/subgraph/ensdomains/ens",children:"https://thegraph.com/explorer/subgraph/ensdomains/ens"})," with the following query."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-text",children:'{\n  domains(where: {name:"vitalik.eth"}) {\n    id\n    name\n    labelName\n    labelhash\n  }\n}\n'})}),"\n",(0,a.jsx)(r.h2,{children:"Handling of Ambiguous Names"}),"\n",(0,a.jsxs)(r.p,{children:["Because of the large number of characters in unicode, and the wide variety of scripts represented, inevitably there are different Unicode characters that are similar or even identical when shown in common fonts. This can be abused to trick users into thinking they are visiting one site or resource, when in fact they are visiting another. This is known as a ",(0,a.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Internationalized_domain_name#ASCII_spoofing_concerns",children:"homoglyph attack"}),"."]}),"\n",(0,a.jsxs)(r.p,{children:["User agents and other software that display names to users should take countermeasures against these attacks, such as by highlighting problematic characters, or showing warnings to users about mixed scripts. ",(0,a.jsx)(r.a,{href:"https://www.chromium.org/developers/design-documents/idn-in-google-chrome",children:"Chromium's IDNA strategy"})," may serve as a useful reference for user-agent behaviour around rendering IDNA names."]})]})}r.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,a.jsx)(o,Object.assign({},e,{children:(0,a.jsx)(c,e)}))}}},function(e){e.O(0,[1577,9214,9774,2888,179],(function(){return r=4539,e(e.s=r);var r}));var r=e.O();_N_E=r}]);