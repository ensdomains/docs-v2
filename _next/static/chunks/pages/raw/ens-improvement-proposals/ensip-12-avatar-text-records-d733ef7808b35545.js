(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3518],{1498:function(e,r,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/raw/ens-improvement-proposals/ensip-12-avatar-text-records",function(){return t(1187)}])},1187:function(e,r,t){"use strict";t.r(r);var n=t(4637),a=t(6988),s=t(1177),i=t(9577),o=function(e){return(0,s.withSSG)((0,a.Z)({filename:"ensip-12-avatar-text-records.mdx",route:"/raw/ens-improvement-proposals/ensip-12-avatar-text-records",meta:{description:"A standard for storage of the avatar text record in ENS."},pageMap:[{name:"developer",children:[{name:"basics",route:"/developer/basics"},{name:"getting-started",route:"/developer/getting-started"},{name:"index",route:"/developer"},{name:"meta.json",meta:{index:{title:"Developer Documentation",type:"docs",theme:{}},"getting-started":{title:"Getting Started",type:"docs"},basics:{title:"Basics",type:"docs"},"working-directly-with-ens":{title:"Manual Contract API",type:"docs"}},locale:"en-US"},{name:"working-directly-with-ens",route:"/developer/working-directly-with-ens"}],route:"/developer"},{name:"governance",children:[{name:"index",route:"/governance"},{name:"meta.json",meta:{index:{title:"Governance Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/governance"},{name:"index",route:"/",frontMatter:{title:"Welcome"}},{name:"meta.json",meta:{index:{title:"Introduction",type:"docs",hidden:!0,theme:{}},about:{title:"About ENS",type:"docs",hidden:!0,theme:{}},user:{title:"User",type:"nav"},developer:{title:"Developer",type:"nav"},technical:{title:"Technical",type:"nav"},governance:{title:"Governance",type:"nav"},raw:{title:"Raw",type:"hidden"}},locale:"en-US"},{name:"raw",children:[{name:"SUMMARY",route:"/raw/SUMMARY"},{name:"bug-bounty-program",route:"/raw/bug-bounty-program"},{name:"contract-api-reference",children:[{name:"ENS-Contracts-Overview",route:"/raw/contract-api-reference/ENS-Contracts-Overview"},{name:"dns-registrar",route:"/raw/contract-api-reference/dns-registrar"},{name:"ens",route:"/raw/contract-api-reference/ens",frontMatter:{description:"The ENS registry."}},{name:"eth-permanent-registrar",children:[{name:"README",route:"/raw/contract-api-reference/eth-permanent-registrar/README"},{name:"controller",route:"/raw/contract-api-reference/eth-permanent-registrar/controller"},{name:"registrar",route:"/raw/contract-api-reference/eth-permanent-registrar/registrar"}],route:"/raw/contract-api-reference/eth-permanent-registrar"},{name:"name-processing",route:"/raw/contract-api-reference/name-processing",frontMatter:{description:"Describes how to normalize and hash ENS names."}},{name:"publicresolver",route:"/raw/contract-api-reference/publicresolver",frontMatter:{description:"The default public resolver."}},{name:"reverseregistrar",route:"/raw/contract-api-reference/reverseregistrar",frontMatter:{description:"The registrar responsible for managing reverse resolution via the .addr.reverse special-purpose TLD."}},{name:"testregistrar",route:"/raw/contract-api-reference/testregistrar"}],route:"/raw/contract-api-reference"},{name:"contract-developer-guide",children:[{name:"resolving-names-on-chain",route:"/raw/contract-developer-guide/resolving-names-on-chain"},{name:"writing-a-registrar",route:"/raw/contract-developer-guide/writing-a-registrar"},{name:"writing-a-resolver",route:"/raw/contract-developer-guide/writing-a-resolver"}],route:"/raw/contract-developer-guide"},{name:"dapp-developer-guide",children:[{name:"ens-as-nft",route:"/raw/dapp-developer-guide/ens-as-nft"},{name:"ens-l2-offchain",route:"/raw/dapp-developer-guide/ens-l2-offchain"},{name:"front-end-design-guidelines",route:"/raw/dapp-developer-guide/front-end-design-guidelines",frontMatter:{description:"ENS is a tool to simplify the experience for your users. Here are a series of guidelines and tools that will help you make design choices and implement the best ENS user experience."}},{name:"managing-names",route:"/raw/dapp-developer-guide/managing-names"},{name:"registering-and-renewing-names",route:"/raw/dapp-developer-guide/registering-and-renewing-names"},{name:"resolving-names",route:"/raw/dapp-developer-guide/resolving-names"}],route:"/raw/dapp-developer-guide"},{name:"deploying-ens-on-a-private-chain",route:"/raw/deploying-ens-on-a-private-chain"},{name:"dns-registrar-guide",route:"/raw/dns-registrar-guide"},{name:"ens-deployments",route:"/raw/ens-deployments"},{name:"ens-improvement-proposals",children:[{name:"README",route:"/raw/ens-improvement-proposals/README",frontMatter:{description:"Standards documentation describing the ENS protocol"}},{name:"ensip-1-ens",route:"/raw/ens-improvement-proposals/ensip-1-ens",frontMatter:{description:"Documentation of the basic ENS protocol (formerly EIP-137)."}},{name:"ensip-10-wildcard-resolution",route:"/raw/ens-improvement-proposals/ensip-10-wildcard-resolution",frontMatter:{description:"Provides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544)."}},{name:"ensip-11-evmchain-address-resolution",route:"/raw/ens-improvement-proposals/ensip-11-evmchain-address-resolution",frontMatter:{description:"Introduces coinType for EVM compatible chains (amending ENSIP9)."}},{name:"ensip-12-avatar-text-records",route:"/raw/ens-improvement-proposals/ensip-12-avatar-text-records",frontMatter:{description:"A standard for storage of the avatar text record in ENS."}},{name:"ensip-2-initial-hash-registrar",route:"/raw/ens-improvement-proposals/ensip-2-initial-hash-registrar",frontMatter:{description:"Describes the hash registrar initially used to register ENS .eth domains (formerly EIP-162)."}},{name:"ensip-3-reverse-resolution",route:"/raw/ens-improvement-proposals/ensip-3-reverse-resolution",frontMatter:{description:"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181)."}},{name:"ensip-4-support-for-contract-abis",route:"/raw/ens-improvement-proposals/ensip-4-support-for-contract-abis",frontMatter:{description:"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205)."}},{name:"ensip-5-text-records",route:"/raw/ens-improvement-proposals/ensip-5-text-records",frontMatter:{description:"A standard for storage of text records in ENS (formerly EIP-634)."}},{name:"ensip-6-dns-in-ens",route:"/raw/ens-improvement-proposals/ensip-6-dns-in-ens",frontMatter:{description:"Defines a resolver profile for ENS that provides features for storage and lookup of DNS records (formerly EIP-1185)."}},{name:"ensip-7-contenthash-field",route:"/raw/ens-improvement-proposals/ensip-7-contenthash-field",frontMatter:{description:"Introduces a field for storing content addresses and hashes in ENS (formerly EIP-1577)."}},{name:"ensip-8-interface-discovery",route:"/raw/ens-improvement-proposals/ensip-8-interface-discovery",frontMatter:{description:"Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces (formerly EIP-1844)."}},{name:"ensip-9-multichain-address-resolution",route:"/raw/ens-improvement-proposals/ensip-9-multichain-address-resolution",frontMatter:{description:"Introduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS (formerly EIP-2304)."}}],route:"/raw/ens-improvement-proposals"},{name:"ens-migration-february-2020",children:[{name:"guide-for-dapp-developers",route:"/raw/ens-migration-february-2020/guide-for-dapp-developers"},{name:"technical-description",route:"/raw/ens-migration-february-2020/technical-description"}],route:"/raw/ens-migration-february-2020"},{name:"frequently-asked-questions",route:"/raw/frequently-asked-questions"},{name:"permanent-registrar-faq",route:"/raw/permanent-registrar-faq"},{name:"terminology",route:"/raw/terminology"}],route:"/raw"},{name:"technical",children:[{name:"about",route:"/technical/about"},{name:"index",route:"/technical"},{name:"meta.json",meta:{index:{title:"Technical Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/technical"},{name:"user",children:[{name:"index",route:"/user"},{name:"meta.json",meta:{index:{title:"User Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/user"}]},i.Z))(e)};function d(e){var r=Object.assign({h1:"h1",table:"table",thead:"thead",tr:"tr",th:"th",strong:"strong",tbody:"tbody",td:"td",h3:"h3",p:"p",a:"a",h4:"h4",code:"code",ol:"ol",li:"li",pre:"pre"},e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{children:"ENSIP-12: Avatar Text Records"}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:(0,n.jsx)(r.strong,{children:"Author"})}),(0,n.jsxs)(r.th,{children:["Nick Johnson ","<nick@ens.domains>",", Makoto Inoue ","<makoto@ens.domains>"]})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"Status"})}),(0,n.jsx)(r.td,{children:"Draft"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:"Submitted"})}),(0,n.jsx)(r.td,{children:"2022-01-18"})]})]})]}),"\n",(0,n.jsx)(r.h3,{children:"Abstract"}),"\n",(0,n.jsxs)(r.p,{children:["This ENSIP defines a process for retrieving avatar URIs from ENS, several ",(0,n.jsx)(r.a,{href:"https://datatracker.ietf.org/doc/html/rfc3986",children:"URI"})," schemes for the ENS 'avatar' text field, and how they should be interpreted by clients wishing to display a user's avatar image."]}),"\n",(0,n.jsx)(r.h3,{children:"Motivation"}),"\n",(0,n.jsx)(r.p,{children:"ENS primary name (formerly known as reverse record) has been widely integrated as a de facto web3 user name across many Ethereum based applications. As multiple apps started specifying avatar profile image as well as let users pick NFT as pfp (profile image), it became obvious to store such information within ENS so that the avatar information can be shared across different applications."}),"\n",(0,n.jsxs)(r.p,{children:["This specification standardises a way to store and retrieve this information using ",(0,n.jsx)(r.a,{href:"ensip-5-text-records.md",children:"ENSIP-5: Avatar Text Records"})]}),"\n",(0,n.jsx)(r.h3,{children:"Specification"}),"\n",(0,n.jsx)(r.h4,{children:"Retrieving the avatar URI"}),"\n",(0,n.jsx)(r.p,{children:"The process for retrieving the avatar URI depends on whether the client has an Ethereum address or an ENS name to start with."}),"\n",(0,n.jsx)(r.h4,{children:"ENS Name"}),"\n",(0,n.jsxs)(r.p,{children:["To determine the avatar URI for an ENS name, the client MUST first look up the resolver for the name and call ",(0,n.jsx)(r.code,{children:".text(namehash(name), 'avatar')"})," on it to retrieve the avatar URI for the name."]}),"\n",(0,n.jsxs)(r.p,{children:["The client MUST treat the absence of a resolver, an revert when calling the ",(0,n.jsx)(r.code,{children:"addr"})," method on the resolver, or an empty string returned by the resolver identically, as a failure to find a valid avatar URI."]}),"\n",(0,n.jsx)(r.h4,{children:"Ethereum Address"}),"\n",(0,n.jsxs)(r.p,{children:["To determine the avatar URI for an Ethereum address, the client MUST reverse-resolve the address by querying the ENS registry for the resolver of ",(0,n.jsx)(r.code,{children:"<address>.addr.reverse"}),", where ",(0,n.jsx)(r.code,{children:"<address>"})," is the lowercase hex-encoded Ethereum address, without leading '0x'. Then, the client calls ",(0,n.jsx)(r.code,{children:".text(namehash('<address>.addr.reverse'), 'avatar')"})," to retrieve the avatar URI for the address."]}),"\n",(0,n.jsxs)(r.p,{children:["If a resolver is returned for the reverse record, but calling ",(0,n.jsx)(r.code,{children:"text"})," causes a revert or returns an empty string, the client MUST call ",(0,n.jsx)(r.code,{children:".name(namehash('<address>.addr.reverse'))"}),". If this method returns a valid ENS name, the client MUST:"]}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["Validate that the reverse record is valid, by resolving the returned name and calling ",(0,n.jsx)(r.code,{children:"addr"})," on the resolver, checking it matches the original Ethereum address."]}),"\n",(0,n.jsx)(r.li,{children:"Perform the process described under 'ENS Name' to look for a valid avatar URI on the name."}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"A failure at any step of this process MUST be treated by the client identically as a failure to find a valid avatar URI."}),"\n",(0,n.jsx)(r.h4,{children:"General Format"}),"\n",(0,n.jsx)(r.p,{children:"The 'avatar' text field MUST be formatted as a URI. Clients MUST ignore URI types they do not recognise, treating them the same as if no value was set for the field."}),"\n",(0,n.jsx)(r.h4,{children:"Image Types"}),"\n",(0,n.jsxs)(r.p,{children:["Clients MUST support images with mime types of ",(0,n.jsx)(r.code,{children:"image/jpeg"}),", ",(0,n.jsx)(r.code,{children:"image/png"}),", and ",(0,n.jsx)(r.code,{children:"image/svg+xml"}),". Clients MAY support additional image types."]}),"\n",(0,n.jsx)(r.h4,{children:"URI Types"}),"\n",(0,n.jsx)(r.p,{children:"All clients SHOULD support the URI schemes defined below. They MAY implement additional schemes not defined in this specification."}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"https"})})}),"\n",(0,n.jsx)(r.p,{children:"If an https URI is provided, it MUST resolve to an avatar image directly. https URLs MUST NOT resolve to HTML pages, metadata, or other content containing the avatar image."}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"ipfs"})})}),"\n",(0,n.jsxs)(r.p,{children:["If an ",(0,n.jsx)(r.a,{href:"https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls",children:"ipfs URI"})," is provided, it MUST resolve to an avatar image directly. Clients without built-in IPFS support MAY rewrite the URI to an https URL referencing an IPFS gateway as described in ",(0,n.jsx)(r.a,{href:"https://docs.ipfs.io/how-to/address-ipfs-on-web/",children:"this document"})," before resolving it as an https URL."]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"data"})})}),"\n",(0,n.jsxs)(r.p,{children:["If a ",(0,n.jsx)(r.a,{href:"https://datatracker.ietf.org/doc/html/rfc2397",children:"data URL"})," is provided, it MUST resolve to an avatar image directly."]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"NFTs"})}),"\n",(0,n.jsxs)(r.p,{children:["A reference to an NFT may be used as an avatar URI, following the standards defined in ",(0,n.jsx)(r.a,{href:"https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-22.md",children:"CAIP-22"})," and ",(0,n.jsx)(r.a,{href:"https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-29.md",children:"CAIP-29"}),"."]}),"\n",(0,n.jsx)(r.p,{children:"Clients MUST support at least ERC721 and ERC1155 type NFTs, and MAY support additional types of NFT."}),"\n",(0,n.jsx)(r.p,{children:"To resolve an NFT URI, a client follows this process:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["Retrieve the metadata URI for the token specified in the ",(0,n.jsx)(r.code,{children:"avatar"})," field URI."]}),"\n",(0,n.jsx)(r.li,{children:"Resolve the metadata URI, fetching the ERC721 or ERC1155 metadata."}),"\n",(0,n.jsx)(r.li,{children:"Extract the image URL specified in the NFT metadata."}),"\n",(0,n.jsx)(r.li,{children:"Resolve the image URL and use it as the avatar."}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["Clients MUST support at least ",(0,n.jsx)(r.code,{children:"https"})," and ",(0,n.jsx)(r.code,{children:"ipfs"})," URIs for resolving the metadata URI and the avatar image, and MAY support additional schemes. Clients MAY implement ",(0,n.jsx)(r.code,{children:"ifps"})," scheme support by rewriting the URI to an HTTPS URL referencing an IPFS gateway as described above."]}),"\n",(0,n.jsx)(r.p,{children:"Clients SHOULD additionally take the following verification steps:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["Where the avatar URI was retrieved via forward resolution (starting from an ENS name), call the ",(0,n.jsx)(r.code,{children:"addr"})," function on the same resolver and for the same name to retrieve the Ethereum address to which the name resolves. Otherwise, if the avatar URI was retrieved via reverse resolution (starting from an Ethereum address), use that address."]}),"\n",(0,n.jsx)(r.li,{children:"Verify that the address from step 1 is an owner of the NFT specified in the URI. If it is not, the client MUST treat the URI as invalid and behave in the same manner as they would if no avatar URI was specified."}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["Clients MAY support NFT URIs by rewriting them to ",(0,n.jsx)(r.code,{children:"https"})," URIs for a service that provides NFT avatar image resolution support."]}),"\n",(0,n.jsx)(r.h3,{children:"Examples"}),"\n",(0,n.jsx)(r.p,{children:"The following examples all resolve to the same avatar image:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"eip155:1/erc721:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d/0 # BAYC token 0\nipfs://QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # IPFS hash for BAYC token 0 image\nhttps://ipfs.io/ipfs/QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # HTTPS URL to IPFS gateway for BAYC token 0 image\n"})}),"\n",(0,n.jsx)(r.h3,{children:"Backwards Compatibility"}),"\n",(0,n.jsx)(r.p,{children:"Not applicable."}),"\n",(0,n.jsx)(r.h3,{children:"Security Considerations"}),"\n",(0,n.jsx)(r.p,{children:"None."}),"\n",(0,n.jsx)(r.h3,{children:"Copyright"}),"\n",(0,n.jsxs)(r.p,{children:["Copyright and related rights waived via ",(0,n.jsx)(r.a,{href:"https://creativecommons.org/publicdomain/zero/1.0/",children:"CC0"}),"."]})]})}r.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,n.jsx)(o,Object.assign({},e,{children:(0,n.jsx)(d,e)}))}}},function(e){e.O(0,[1577,9214,9774,2888,179],(function(){return r=1498,e(e.s=r);var r}));var r=e.O();_N_E=r}]);