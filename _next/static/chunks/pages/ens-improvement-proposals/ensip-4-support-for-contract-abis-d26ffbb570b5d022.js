(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3830],{3912:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/ens-improvement-proposals/ensip-4-support-for-contract-abis",function(){return r(6634)}])},6634:function(e,n,r){"use strict";r.r(n);var t=r(4637),s=r(6988),o=r(1177),i=r(2370),a=function(e){return(0,o.withSSG)((0,s.Z)({filename:"ensip-4-support-for-contract-abis.mdx",route:"/ens-improvement-proposals/ensip-4-support-for-contract-abis",meta:{description:"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205)."},pageMap:[{name:"README",route:"/README"},{name:"SUMMARY",route:"/SUMMARY"},{name:"bug-bounty-program",route:"/bug-bounty-program"},{name:"contract-api-reference",children:[{name:"ENS-Contracts-Overview",route:"/contract-api-reference/ENS-Contracts-Overview"},{name:"dns-registrar",route:"/contract-api-reference/dns-registrar"},{name:"ens",route:"/contract-api-reference/ens",frontMatter:{description:"The ENS registry."}},{name:"eth-permanent-registrar",children:[{name:"README",route:"/contract-api-reference/eth-permanent-registrar/README"},{name:"controller",route:"/contract-api-reference/eth-permanent-registrar/controller"},{name:"registrar",route:"/contract-api-reference/eth-permanent-registrar/registrar"}],route:"/contract-api-reference/eth-permanent-registrar"},{name:"name-processing",route:"/contract-api-reference/name-processing",frontMatter:{description:"Describes how to normalize and hash ENS names."}},{name:"publicresolver",route:"/contract-api-reference/publicresolver",frontMatter:{description:"The default public resolver."}},{name:"reverseregistrar",route:"/contract-api-reference/reverseregistrar",frontMatter:{description:"The registrar responsible for managing reverse resolution via the .addr.reverse special-purpose TLD."}},{name:"testregistrar",route:"/contract-api-reference/testregistrar"}],route:"/contract-api-reference"},{name:"contract-developer-guide",children:[{name:"resolving-names-on-chain",route:"/contract-developer-guide/resolving-names-on-chain"},{name:"writing-a-registrar",route:"/contract-developer-guide/writing-a-registrar"},{name:"writing-a-resolver",route:"/contract-developer-guide/writing-a-resolver"}],route:"/contract-developer-guide"},{name:"dapp-developer-guide",children:[{name:"ens-as-nft",route:"/dapp-developer-guide/ens-as-nft"},{name:"ens-enabling-your-dapp",route:"/dapp-developer-guide/ens-enabling-your-dapp"},{name:"ens-l2-offchain",route:"/dapp-developer-guide/ens-l2-offchain"},{name:"ens-libraries",route:"/dapp-developer-guide/ens-libraries"},{name:"front-end-design-guidelines",route:"/dapp-developer-guide/front-end-design-guidelines",frontMatter:{description:"ENS is a tool to simplify the experience for your users. Here are a series of guidelines and tools that will help you make design choices and implement the best ENS user experience."}},{name:"managing-names",route:"/dapp-developer-guide/managing-names"},{name:"registering-and-renewing-names",route:"/dapp-developer-guide/registering-and-renewing-names"},{name:"resolving-names",route:"/dapp-developer-guide/resolving-names"},{name:"working-with-ens",route:"/dapp-developer-guide/working-with-ens"}],route:"/dapp-developer-guide"},{name:"deploying-ens-on-a-private-chain",route:"/deploying-ens-on-a-private-chain"},{name:"developer",children:[{name:"index",route:"/developer"},{name:"meta.json",meta:{index:{title:"Developer Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/developer"},{name:"dns-registrar-guide",route:"/dns-registrar-guide"},{name:"ens-deployments",route:"/ens-deployments"},{name:"ens-improvement-proposals",children:[{name:"README",route:"/ens-improvement-proposals/README",frontMatter:{description:"Standards documentation describing the ENS protocol"}},{name:"ensip-1-ens",route:"/ens-improvement-proposals/ensip-1-ens",frontMatter:{description:"Documentation of the basic ENS protocol (formerly EIP-137)."}},{name:"ensip-10-wildcard-resolution",route:"/ens-improvement-proposals/ensip-10-wildcard-resolution",frontMatter:{description:"Provides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544)."}},{name:"ensip-11-evmchain-address-resolution",route:"/ens-improvement-proposals/ensip-11-evmchain-address-resolution",frontMatter:{description:"Introduces coinType for EVM compatible chains (amending ENSIP9)."}},{name:"ensip-12-avatar-text-records",route:"/ens-improvement-proposals/ensip-12-avatar-text-records",frontMatter:{description:"A standard for storage of the avatar text record in ENS."}},{name:"ensip-2-initial-hash-registrar",route:"/ens-improvement-proposals/ensip-2-initial-hash-registrar",frontMatter:{description:"Describes the hash registrar initially used to register ENS .eth domains (formerly EIP-162)."}},{name:"ensip-3-reverse-resolution",route:"/ens-improvement-proposals/ensip-3-reverse-resolution",frontMatter:{description:"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181)."}},{name:"ensip-4-support-for-contract-abis",route:"/ens-improvement-proposals/ensip-4-support-for-contract-abis",frontMatter:{description:"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205)."}},{name:"ensip-5-text-records",route:"/ens-improvement-proposals/ensip-5-text-records",frontMatter:{description:"A standard for storage of text records in ENS (formerly EIP-634)."}},{name:"ensip-6-dns-in-ens",route:"/ens-improvement-proposals/ensip-6-dns-in-ens",frontMatter:{description:"Defines a resolver profile for ENS that provides features for storage and lookup of DNS records (formerly EIP-1185)."}},{name:"ensip-7-contenthash-field",route:"/ens-improvement-proposals/ensip-7-contenthash-field",frontMatter:{description:"Introduces a field for storing content addresses and hashes in ENS (formerly EIP-1577)."}},{name:"ensip-8-interface-discovery",route:"/ens-improvement-proposals/ensip-8-interface-discovery",frontMatter:{description:"Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces (formerly EIP-1844)."}},{name:"ensip-9-multichain-address-resolution",route:"/ens-improvement-proposals/ensip-9-multichain-address-resolution",frontMatter:{description:"Introduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS (formerly EIP-2304)."}}],route:"/ens-improvement-proposals"},{name:"ens-migration-february-2020",children:[{name:"guide-for-dapp-developers",route:"/ens-migration-february-2020/guide-for-dapp-developers"},{name:"technical-description",route:"/ens-migration-february-2020/technical-description"}],route:"/ens-migration-february-2020"},{name:"frequently-asked-questions",route:"/frequently-asked-questions"},{name:"governance",children:[{name:"index",route:"/governance"},{name:"meta.json",meta:{index:{title:"Governance Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/governance"},{name:"index",route:"/",frontMatter:{title:"Welcome"}},{name:"meta.json",meta:{index:{title:"Introduction",type:"docs",hidden:!0,theme:{}},governance:{title:"Governance",type:"nav"},user:{title:"User",type:"nav"},developer:{title:"Developer",type:"nav"},technical:{title:"Technical",type:"nav"}},locale:"en-US"},{name:"permanent-registrar-faq",route:"/permanent-registrar-faq"},{name:"technical",children:[{name:"index",route:"/technical"},{name:"meta.json",meta:{index:{title:"Technical Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/technical"},{name:"terminology",route:"/terminology"},{name:"user",children:[{name:"index",route:"/user"},{name:"meta.json",meta:{index:{title:"User Documentation",type:"docs",theme:{}}},locale:"en-US"}],route:"/user"}]},i.Z))(e)};function c(e){var n=Object.assign({h1:"h1",table:"table",thead:"thead",tr:"tr",th:"th",strong:"strong",tbody:"tbody",td:"td",h3:"h3",p:"p",h4:"h4",a:"a",pre:"pre",code:"code"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"ENSIP-4: Support for contract ABIs"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Author"})}),(0,t.jsxs)(n.th,{children:["Nick Johnson ","<nick@ens.domains>"]})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Status"})}),(0,t.jsx)(n.td,{children:"Final"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Submitted"})}),(0,t.jsx)(n.td,{children:"2017-02-06"})]})]})]}),"\n",(0,t.jsx)(n.h3,{children:"Abstract"}),"\n",(0,t.jsx)(n.p,{children:"ABIs are important metadata required for interacting with most contracts. At present, they are typically supplied out-of-band, which adds an additional burden to interacting with contracts, particularly on a one-off basis or where the ABI may be updated over time. The small size of ABIs permits an alternative solution, storing them in ENS, permitting name lookup and ABI discovery via the same process."}),"\n",(0,t.jsx)(n.p,{children:"ABIs are typically quite compact; the largest in-use ABI we could find, that for the DAO, is 9450 bytes uncompressed JSON, 6920 bytes uncompressed CBOR, and 1128 bytes when the JSON form is compressed with zlib. Further gains on CBOR encoding are possible using a CBOR extension that permits eliminating repeated strings, which feature extensively in ABIs. Most ABIs, however, are far shorter than this, consisting of only a few hundred bytes of uncompressed JSON."}),"\n",(0,t.jsx)(n.p,{children:"This ENSIP defines a resolver profile for retrieving contract ABIs, as well as encoding standards for storing ABIs for different applications, allowing the user to select between different representations based on their need for compactness and other considerations such as onchain access."}),"\n",(0,t.jsx)(n.h3,{children:"Specification"}),"\n",(0,t.jsx)(n.h4,{children:"ABI encodings"}),"\n",(0,t.jsx)(n.p,{children:"In order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint."}),"\n",(0,t.jsx)(n.p,{children:"The currently recognised encodings are:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"ID"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"JSON"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"zlib-compressed JSON"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"CBOR"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"8"}),(0,t.jsx)(n.td,{children:"URI"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"This table may be extended in future through the ENSIP process."}),"\n",(0,t.jsx)(n.p,{children:"Encoding type 1 specifies plaintext JSON, uncompressed; this is the standard format in which ABIs are typically encoded, but also the bulkiest, and is not easily parseable onchain."}),"\n",(0,t.jsx)(n.p,{children:"Encoding type 2 specifies zlib-compressed JSON. This is significantly smaller than uncompressed JSON, and is straightforward to decode offchain. However, it is impractical for onchain consumers to use."}),"\n",(0,t.jsxs)(n.p,{children:["Encoding type 4 is ",(0,t.jsx)(n.a,{href:"https://cbor.io",children:"CBOR"}),". CBOR is a binary encoding format that is a superset of JSON, and is both more compact and easier to parse in limited environments such as the EVM. Consumers that support CBOR are strongly encouraged to also support the ",(0,t.jsx)(n.a,{href:"http://cbor.schmorp.de/stringref",children:"stringref extension"})," to CBOR, which provides significant additional reduction in encoded size."]}),"\n",(0,t.jsx)(n.p,{children:"Encoding type 8 indicates that the ABI can be found elsewhere, at the specified URI. This is typically the most compact of the supported forms, but also adds external dependencies for implementers. The specified URI may use any schema, but HTTP, IPFS, and Swarm are expected to be the most common."}),"\n",(0,t.jsx)(n.h4,{children:"Resolver profile"}),"\n",(0,t.jsx)(n.p,{children:"A new resolver interface is defined, consisting of the following method:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function ABI(bytes32 node, uint256 contentType) constant returns (uint256, bytes);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The interface ID of this interface is 0x2203ab56."}),"\n",(0,t.jsxs)(n.p,{children:["contentType is a bitfield, and is the bitwise OR of all the encoding types the caller will accept. Resolvers that implement this interface must return an ABI encoded using one of the requested formats, or ",(0,t.jsx)(n.code,{children:'(0, "")'})," if they do not have an ABI for this function, or do not support any of the requested formats."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"abi"})," resolver profile is valid on both forward and reverse records."]}),"\n",(0,t.jsx)(n.h4,{children:"ABI lookup process"}),"\n",(0,t.jsx)(n.p,{children:"When attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to."}),"\n",(0,t.jsx)(n.p,{children:"Implementers should support as many of the ABI encoding formats as practical."}),"\n",(0,t.jsx)(n.h3,{children:"Rationale"}),"\n",(0,t.jsx)(n.p,{children:"Storing ABIs onchain avoids the need to introduce additional dependencies for applications wishing to fetch them, such as swarm or HTTP access. Given the typical compactness of ABIs, we believe this is a worthwhile tradeoff in many cases."}),"\n",(0,t.jsx)(n.p,{children:"The two-step resolution process permits different names to provide different ABIs for the same contract, such as in the case where it's useful to provide a minimal ABI to some callers, as well as specifying ABIs for contracts that did not specify one of their own. The fallback to looking up an ABI on the reverse record permits contracts to specify their own canonical ABI, and prevents the need for duplication when multiple names reference the same contract without the need for different ABIs."}),"\n",(0,t.jsx)(n.h3,{children:"Copyright"}),"\n",(0,t.jsxs)(n.p,{children:["Copyright and related rights waived via ",(0,t.jsx)(n.a,{href:"https://creativecommons.org/publicdomain/zero/1.0/",children:"CC0"}),"."]})]})}n.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,t.jsx)(a,Object.assign({},e,{children:(0,t.jsx)(c,e)}))}}},function(e){e.O(0,[8164,3248,9774,2888,179],(function(){return n=3912,e(e.s=n);var n}));var n=e.O();_N_E=n}]);